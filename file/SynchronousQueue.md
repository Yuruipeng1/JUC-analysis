## 1.SynchronousQueue栈transfer方法逻辑

首先获取头节点head，如果队列为空或者模式相同，说明队列中只有相同节点,

然后判断是计时操作，并且时间<0,说明这是一次尝试（如果队列中有匹配的就匹配，没有的话就直接返回null），这时候看head是不是取消节点，是的话就cashead为head的next节点（帮队列做一点事），返回null。  如果不是计时操作或者是计时并且时间>0,把新建节点插入到栈的顶部，并且cas设置head为新建节点，然后调用awaitFulfill方法让新建节点去阻塞等待匹配节点，这个方法如果返回了，那么是返回它的匹配节点，这时候判断如果返回节点是它自己，说明它是被中断或者取消才返回的，就将这个节点从栈中移除，并且返回null。 如果是正常返回，就将栈中最上面的两个节点出队，并且cas设置head为这个节点的next，（因为这个节点被匹配说明它的前驱也就是新加入进来的节点是相反模式）最后判断当前节点是不是REQUEST如果是说明当前节点是消费者，那么返回它匹配节点的item，如果不是REQUEST，说明当前节点是生产者，返回它的item。（反正谁是生产者就返回谁的item就完事了，毕竟得返回一个值）



如果队列中节点得模式相反（并且不是fulfilling node这个代表head节点正在匹配），首先如果head为取消节点，就把head出队然后重新开始循环，创建一个状态位为fulfill的当前节点（s），并且把head指向这个节点，接着拿到当前节点得下一个节点，也就是要匹配得那个节点(m)，判断它是否为null（为null，说明被匹配节点被中断或超时，导致节点被取消了，并且被匹配节点是最后一个节点，此时栈中只有匹配节点），这是清空整个栈，然后重新开始循环，不为null，拿到m.next mn，然后s和m进行匹配，如果成功，casHead(s,mn)，然后返回生产者得item。如果匹配失败，说明m是个取消节点，s.casNext=mn。



如果当前head正在进行匹配，那么帮助他们进行匹配，逻辑和匹配逻辑类似。



## 2.SynchronousQueue队列transfer方法逻辑

首先拿到队列得head和tail，如果其中有一个为null，就continue重新开始循环获取值， 如果h==t，或者tail的模式和要加入节点的模式相同，如果发现t!=tail, 说明tail已经该变了，需要重新开始循环， 如果t==tail，但是t.next!=null,说明遇到了别的线程添加节点后还没更新tail，这时候帮助更新队列的tail，然后continue重新开始循环。

下面是tail没更新并且t是最后一个节点的逻辑，首先看是不是一次尝试版本，如果是，直接返回null，因为此时是没有可以匹配的节点，否则，创建当前要插入的节点(s)，t.casNext(null,s), 失败的话continue重新开始循环，如果成功了，更新tail为最新入队的节点（也是用cas操作），上面操作完成后，当前插入节点s就需要调用awaitFulfill方法去阻塞，当它从这个方法返回时，会返回和它匹配的节点（x），如果x==s，这种情况说明当前s节点被中断或者被取消了，就需要从队列中把s清除，然后返回null。 如果当前s节点是被匹配而唤醒的，cas修改head为s节点，然后把s节点属性置为null（成为一个dummy node）， 最后返回生产者的item。



如果当前插入节点模式和队列中模式相反，此时走匹配的逻辑，首先判断  if (t != tail || m == null || h != head)  这说明当前队列结构已经发生改变了（在并发环境下，什么情况都有可能发生），重新contune开始循环，这个条件不成立，就拿到head.next（m）,这是队列中真正的第一个有效节点（因为这个队列存在dummy node），if (isData == (x != null) ||     x == m ||   !m.casItem(x, e))  进入这个if条件，说明要么是m已经被匹配了，要么是m被中断或超时取消了，要么是有别的线程抢先一步匹配了，这时，就帮忙设置新的头节点，并且把旧的head出队，然后continue重新循环， 走到下面的逻辑说明匹配成功了，先改变head的指向，然后唤醒被匹配的那个节点，最后返回匹配双方中生产者节点的item值。



## 3.为什么在SynchronousQueue队列的clean方法中，如果传入节点s是tail节点，它不会进行移除操作？

当发现s节点为tail时，此次调用不会移除掉它，而是留到下一次调用此函数再清理。因为下一次调用s就不再是队尾tail了。

当发现s是tail且cleanMe没被占领时，不执行移除动作，而是通过casCleanMe(null, pred)把需要移除节点的前驱暂时保存起来。
当发现s是tail且cleanMe被占领时，先移除cleanMe的后继，然后再通过casCleanMe(null, pred)把需要移除节点的前驱暂时保存起来。

如果执行删除tail操作，假如有这样一个结构   a-->b-->c(tail)  ,要变成a-->b(tail) ，这需要经过两次cas操作，设置b的next为null和设置tail的新值为b，那么别的线程就可能看到这两个结构， a-->b-->null,   c(tail)-->null ，这可能导致别的线程入队时，会插入到c的后面，而c已经不在队列中了，这就会出现问题，所以对于tail节点的删除等到下一次操作再进行就能避免这个问题。
