## 1.ConcurrentSkipListMap的底层实现是什么？

ConcurrentSkipListMap底层实现是跳表，结构如下：

base层：最下面的层（第0层），节点类型为Node。第一个节点是dummy节点。
index层：第1层或以上，节点类型为Index。
node节点：base层的节点。
index节点：index层的节点。
headIndex节点：index层的头节点。
marker：不存储数据，只是为了删除时使用。
被标记为删除：Node的value为置为null。简称为“被标记”。

```java
* Head nodes          Index nodes
* +-+    right        +-+                      +-+
* |2|---------------->| |--------------------->| |->null
* +-+                 +-+                      +-+
*  | down              |                        |
*  v                   v                        v
* +-+            +-+  +-+       +-+            +-+       +-+
* |1|----------->| |->| |------>| |----------->| |------>| |->null
* +-+            +-+  +-+       +-+            +-+       +-+
*  v              |    |         |              |         |
* Nodes  next     v    v         v              v         v
* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
* | |->|A|->|B|->|C|->|D|->|E|->|F|->|G|->|H|->|I|->|J|->|K|->null
* +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+
```

这便是ConcurrentSkipListMap的基本样子。



## 2.ConcurrentSkipListMap的查找逻辑？

该操作分为两部分，**找到目标节点的前驱**和**找到目标节点**

**找到目标节点的前驱**： 调用findPredecessor方法，该函数只在index层里寻找<参数key的那个index节点，并返回这个index节点的node成员。如果能找到，那么返回一个真实的node；否则返回base层的header（一个dummy node）。在寻找的过程中还会断开与删除的index节点的链接。首先从最高层的第一个（q）和第二个节点（r）开始（第一个是一个dummy node），判断第二个节点是否是一个删除节点，如果是就断开他们的链接，并且把第一个和第二个的right链接起来，然后continue，如果不是就判断目标key和r的大小，如果key>r,说明r在key的前面，但是不一定是它的前驱，可能还有更大的，这时候就右移，q=r，r=r.right。 如果key<=r,这时候就不能右移了，需要向下移动，如果q.down==null，说明已经找到了前驱就是q直接返回q.node，如果不为null，则执行q=d，r=d.right，然后继续循环，这时候就是去下一层寻找，可能也会有右移操作和左移操作。



**找到目标节点**： b作为找到的前驱，n=b.next，如果n==null，如果目标节点不存在，直接返回null。 定义一个f=n.next

这时候有一个这样的结构 **b-->n-->f**, 再判断n！=b.next, 说明有别的其他线程进行了修改，这时候得重新开始获取b，n，f（外面是两个双层死循环），如果n.value 为null，说明n节点被删除了，此时就得调用helpDelete方法帮助删除，然后break重新获取值开始循环， 如果b被删除，或者n是一个marker节点（它的value==this），那么break，重新获取值循环， 终于走到了判断逻辑，如果key==n.key说明找到了目标节点，直接返回,如果key<n.key，那么目标不可能找到了，直接返回null， 如果key>n.key ，这说明还是有可能找到执行base层的右移操作。



## 3.ConcurrentSkipListMap的插入逻辑？

插入逻辑可以分为三个部分， 第一个部分，插入新节点，  第二部分，为这个新节点创建垂直方向上的Index节点，第三部分，为这些Index设置左右链接。

**插入新节点**:  逻辑和上面的查找逻辑差不多，先找到前驱 n，然后b-->n-->f，有一些判断和查找逻辑一样就略过，然后判断key>n.key,这时候就得右移，如果key==n.key，说明找到了相同节点，这时候根据onlyifAbsent来替换，如果key<n.key, 这时候就找到了插入的位置，直接把目标节点插入到 b 和n之间

**创建垂直方向上的Index节点**：首先通过ThreadLocalRandom.nextSecondarySeed() 算出一个int值，然后根据它最高位和最低位之间的位数中1的数量，得到一个创建的level，也就是层数。如果这个level小于最大层数，就创建level层,自低向上建立index，但每个新建index的前后的right指针还没好。  如果大于最大层数，则创建最大层数+1,  创建一个Index数组，从1到level的数组索引，用来放从1到level的新建index，0元素不使用，//自低向上建立index，但每个新建index的前后的right指针还没好,依次放在数组里，然后还需要把 超过原长度的那几层再建立HeadIndex节点，并且将right链接起来，然后用变量保存原长度的那一层的level和Index，最后不管是level大于还是小于，进入第三部分都只要处理原来的长度的那几个元素。

**Index设置左右链接**：首先从最高层数开始，按照查找的逻辑找到插入节点的第一个要设置左右链接Index位置，将其链接起来，然后开始下移，找到下一层的那个Index，一直循环直到所有的Index都链接完毕了，就返回。



## 4.ConcurrentSkipListMap的删除逻辑？

前半部分的逻辑和插入逻辑类似，然后判断传入的key和找到的前驱的后继进行比较，如果key<n.key,直接break，返回null，如果key>n.key,则执行后移操作然后继续循环，如果key==n.key，说明找到了删除节点就是n，首先cas修改n的value为null，然后cas修改n的后继为marker节点，并且marker节点的后继为f，最后cas修改b的后继为f，如果以上操作都成功了，调用findPredecessor方法，清除删除节点的Index节点。删除成功最后会返回删除节点的value。



## 5.在删除逻辑中为什么要有marker节点，marker节点存在的意义是什么？

```java
/**
 * 这个marker节点存在的必要性？
 * 这是为了并发删除和插入操作的正确性,
 * 如果marker节点不存在：假设有 b->n->f 这时候插入一个a节点，并且在n和f之间，因为是并发执行，假设a在插入前判断n不是一个删除
 * 节点，但是在插入时n被删除了，假如插入先执行，此时 b->n->a->f  ,然后再执行删除操作（删除操作是直接b->f）,这时候a就脱离链表了
 * 假如删除操作先执行b->f ,  然后执行a的插入操作，但是这时候a还是认为他的前驱是n，所以形成n->a->f ,但是在链表上a也脱离链表了
 * 所以这样不管插入操作和删除操作谁先执行，a节点都会失效。
 *
 * 如果marker节点存在：插入操作是插入节点先指向后继（1），再让他的前驱指向插入节点（2），删除操作是先把删除节点置为null（3），
 * 再在节点后面插入一个marker（marker也会和删除节点的后继相连）（4），然后再把删除节点的前驱指向后继（5）
 * 我把这几个操作编个号然后讨论他们在并发情况下交叉执行的结果
 * 如果是1，3，4，5，2 ，此时n的后继已经是marker了，执行n.cas(f,a)会失败，然后会重新获取新的插入操作，这就不会出问题
 * 如果是1，3，4，2，5   插入线程执行n.casNext(f, 啊、)会失败，因为n的后继不再是f，而是一个marker。然后插入线程会重新从head寻找插入位置。
 * 如果是1，3，2，4，5   当执行到n.casNext(f, new markerNode(f))时此时因为2的操作n的后继已经不是f了而是a，所以会失败，此时删除线程会重新从head寻找删除节点（findNode）
 * 如果时1，2，3，4，5   分析和1，3，2，4，5是一样的
 * 可以看到不管是那种交叉最终都能保证不会得到错误的结果(会去失败重新获取最新的值)
 *
 *
 * 从本质上来说，因为删除过程的第一步是插入一个marker，这就把删除操作也变成了“插入操作”，
 * 自然作为“插入操作”的删除操作会和正常的插入操作会互斥，从而保证了并发删除和插入能有正常的结果
 */
```
