## 1.ConcurrentLinkedQueue是什么?

ConcurrentLinkedQueue是一种FIFO（first-in-first-out 先入先出）的无界队列，底层是单链表，一般来说，队列只支持队尾入队、队头出队，但此类还支持从内部删除某个特定的节点。使用非阻塞算法来处理并发操作，这也意味着实现里充满了CAS和自旋。

ConcurrentLinkedQueue和普通的队列有一点不同，它的head和tail节点可能不是最新的，它默认规则是两次一修改，拿队尾举例，第一次插入元素，tail节点不会马上更新，可能要等到第二次插入节点后才会更新tail，队头也是这样的逻辑。这两个变量都是volatile修饰，并且修改时用cas进行修改，所以如果要修改tail，那么要进行两次cas，cas修改tail.next和cas修改tail指向新的节点，因为两次cas是不能保证原子性的，所以干脆摒弃强一致性的原则，采用弱一致性的思想，牺牲一点准确度来提高效率，并且由于不会马上修改头尾节点，cas的次数也随之减少，进一步提高了效率。



## 2.为node节点的item赋值为什么不用this.item=item这种操作?

在node节点中item的赋值操作是UNSAFE.putObject(this, itemOffset, item)，putObject调用的是JNI方法，直接跳过jvm的控制，直接操作内存，因为item是volatile修饰的，这样就能跳过volatile的语义(会有读写屏障的操作，有一定的性能损耗)，进一步提高效率。

因为volatile是保证可见性的，而这里暂时可以不保证，因为节点刚刚创建还没有入队，就没有保证可见性而言，当它入队后，会有相应的cas操作会帮它保证可见性。



## 3.为什么插入节点时，是两次一修改，而不是3，4，5次？

插入一个值，不修改头尾节点，弱一致性，高性能，弱一致性带来的坏处首先是数据的不准确，另外，它还会使得插入节点时，循环遍历的次数变多（插入逻辑导致），所以如果每间隔很多次才修改，那么要遍历很多次最后才会修改tail或head，这也会带来性能的损耗，所以要做平衡，平衡弱一致性和并发性能。

后续也能根据自己项目的场景来自定义几次一修改，来获取更高效的性能。



## 4.ConcurrentLinkedQueue插入节点逻辑

首先获取t=tail, p=t, q=p.next，然后判断q是否为null，如果q为null，说明p是最后一个节点，cas尝试入队，如果成功，则判断p!=t(这说明新插入节点距离tail已经为2了)那么此时就需要更新tail为最新节点，如果p==t，说明tail之前已经是最新的了，新插入一个节点的话距离为1，不会更新，然后返回true。

如果q！=null，说明p不是最后一个节点，接着判断p==q，如果成立，说明p后继指向自身，说明p是已删除节点，循环变量p已经不在队列上了，这时候我们已经无法向后遍历了，如果此时tail没有发生变化，那么无计可施了，只能获取head节点从头开始遍历，如果tail已经发生变化，那么说明有别的线程帮我们做了上述的操作并更新tail节点，这时候我们只需要从tail开始遍历就行。

 如果p不是删除节点并且不是最后一个节点，那么此时就需要后移了，如果p！=t，并且tail发生了变化，那么此时将p指向最新的tail，否则我们将p指向q往后遍历。



## 5.ConcurrentLinkedQueue出队逻辑



首先获取h=head，p=h ， 如果p的item不为null，并且pcasitem为null成功，此时判断p！=h，如果成立，说明此时h和p的距离至少为1，所以此时head和p的后继(可能的有效节点)距离至少为2了，所以此时要更新head节点，如果q（p的后继）不为null，那么cas修改head为q，否则cas修改为p，因为后面没有节点了，最后返回p的item。

如果p的item发现为null 或者 p的item发现不为null，但CAS失败。说明别的线程抢先了出队操作,那么p的item也会为null的，此时判断q（p的后继）是否为null，如果为null，更新cas head为p，返回null，代表队列中无节点了。

如果q不为null，此时判断p==q，说明p自链了，p是一个删除节点，脱离队列，直接重新开始循环重新获取值。

如果p!=q,那么直接p=q往后遍历就行。





